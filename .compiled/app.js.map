{"version":3,"sources":["../server/app.js"],"names":["app","PORT","console","log","TextToIPA","loadDict","get","req","res","params","word","ipa_translation","lookup","responce_json","error","text","send","error_responce","isSentence","words","sentence","sentenceArray","split","map","cleanup","ipa_words","value","trim","sentence_ipa","reduce","accumulator","currentValue","JSON","stringify","listen"],"mappings":";;AAAA;;;;AAEA;;;;AACA;;;;AAFA;AAIA,IAAMA,MAAM,wBAAZ;AACA,IAAMC,OAAO,IAAb;AACAC,QAAQC,GAAR,CAAY,qBAAqBF,IAAjC;;AAEAG,oBAAUC,QAAV;;AAEA;AACAL,IAAIM,GAAJ,CAAQ,gBAAR,EAA0B,UAAUC,GAAV,EAAeC,GAAf,EAAoB;;AAE1C,QAAGD,IAAIE,MAAJ,CAAWC,IAAd,EAAmB;AACf,YAAIA,OAAOH,IAAIE,MAAJ,CAAWC,IAAtB;AACA,YAAIC,kBAAkBP,oBAAUQ,MAAV,CAAiBF,IAAjB,CAAtB;;AAEAR,gBAAQC,GAAR,CAAYQ,eAAZ;AACA,YAAIE,gBAAgB;AACX,oBAAQH,IADG;AAEZ,qBAASC,gBAAgBG,KAAhB,IAAyB,WAAzB,GAAuC,gBAAvC,GAAwD,MAFrD;AAGZ,+BAAmBH,gBAAgBI,IAHvB;AAIZ,uBAAW;AAJC,SAApB;AAMAP,YAAIQ,IAAJ,CAASH,aAAT;AAEH,KAbD,MAaK;AACDX,gBAAQC,GAAR,CAAY,uBAAZ;AACA,YAAIc,iBAAiBV,IAAIE,MAAzB;AACAQ,uBAAe,OAAf,IAAyB,uBAAzB;AACAT,YAAIQ,IAAJ,CAASC,cAAT;AACH;AAGJ,CAvBD;;AA0BA;AACAjB,IAAIM,GAAJ,CAAQ,oBAAR,EAA6B,UAACC,GAAD,EAAKC,GAAL,EAAW;AACpC,QAAIU,aAAaX,IAAIE,MAAJ,CAAWU,KAA5B;AACA,QAAIN,gBAAgB;AAChB,iBAAQ,EADQ;AAEhB,oBAAW,EAFK;AAGhB,wBAAe,EAHC;AAIhB,qBAAY;AAJI,KAApB;;AAOA,QAAGK,UAAH,EAAe;AACX,YAAIE,WAAWb,IAAIE,MAAJ,CAAWU,KAA1B;AACA,YAAIE,gBAAgB,EAApB;AACAA,wBAAgBD,SAASE,KAAT,CAAe,KAAf,CAAhB,CAHW,CAG0B;AACrC;AACA;AACA;;AAEAD,wBAAgBA,cAAcE,GAAd,CAAkBC,gBAAlB,CAAhB;AACAtB,gBAAQC,GAAR,CAAYkB,aAAZ;AACAR,sBAAcY,SAAd,GAA0BJ,cAAcE,GAAd,CAAkB,UAACG,KAAD,EAAS;AACnD,mBAAOtB,oBAAUQ,MAAV,CAAiBc,KAAjB,EAAwBX,IAA/B;AACD,SAFyB,CAA1B;;AAIA;AACA;AACA;AACA;AACAF,sBAAcY,SAAd,GAA0BZ,cAAcY,SAAd,CAAwBF,GAAxB,CAA4B,UAACb,IAAD,EAAQ;AAC1D,mBAAOA,KAAKY,KAAL,CAAW,IAAX,EAAiBC,GAAjB,CAAqB,UAACG,KAAD,EAAS;AAAE,uBAAOA,MAAMC,IAAN,EAAP;AAAoB,aAApD,EAAsD,CAAtD,CAAP;AACH,SAFyB,CAA1B;;AAIA;AACAd,sBAAce,YAAd,GAA6Bf,cAAcY,SAAd,CAAwBI,MAAxB,CAA+B,UAACC,WAAD,EAAcC,YAAd,EAA8B;AACtF,mBAAOD,cAAa,GAAb,GAAkBC,YAAzB;AACH,SAF4B,CAA7B;;AAIAvB,YAAIQ,IAAJ,CAASgB,KAAKC,SAAL,CAAepB,aAAf,CAAT;AACH,KA5BD,MA4BK;AACDL,YAAIQ,IAAJ,CAASgB,KAAKC,SAAL,CAAepB,aAAf,CAAT;AACH;AACJ,CAxCD;;AA0CAb,IAAIkC,MAAJ,CAAWjC,IAAX,EAAiB;AAAA,WAAMC,QAAQC,GAAR,oCAA6CF,IAA7C,OAAN;AAAA,CAAjB","file":"app.js","sourcesContent":["import express from 'express'\r\n//https://www.npmjs.com/package/text-to-ipa\r\nimport TextToIPA from 'text-to-ipa'\r\nimport { cleanup } from './lib/helpers'\r\n\r\nconst app = express()\r\nconst PORT = 3000\r\nconsole.log(\"Server Started: \" + PORT)\r\n\r\nTextToIPA.loadDict();\r\n\r\n//main endpoint for server\r\napp.get('/v1/word/:word', function (req, res) {\r\n\r\n    if(req.params.word){\r\n        let word = req.params.word\r\n        let ipa_translation = TextToIPA.lookup(word)\r\n\r\n        console.log(ipa_translation)\r\n        let responce_json = {\r\n                 \"word\": word,\r\n                \"error\": ipa_translation.error == \"undefined\" ? \"Word Not found\":\"None\",\r\n                \"ipa_translation\": ipa_translation.text,\r\n                \"version\": \"v1\"\r\n        }\r\n        res.send(responce_json)\r\n\r\n    }else{\r\n        console.log(\"ERROR: word not found\")\r\n        let error_responce = req.params\r\n        error_responce[\"error\"] =\"ERROR: word not found\"\r\n        res.send(error_responce)     \r\n    }\r\n    \r\n\r\n})\r\n\r\n\r\n// words enpoint\r\napp.get(\"/v1/senence/:words\",(req,res)=>{\r\n    let isSentence = req.params.words\r\n    let responce_json = {\r\n        \"error\":\"\",\r\n        \"sentence\":\"\",\r\n        \"sentence_ipa\":\"\",\r\n        \"ipa_words\":[]\r\n    }\r\n\r\n    if(isSentence) {\r\n        let sentence = req.params.words\r\n        let sentenceArray = []\r\n        sentenceArray = sentence.split(/\\s+/)//split on space ex: .split(\" \")\r\n        // sentenceArray = sentenceArray.map((value)=> {\r\n        //     return  cleanup(value)\r\n        // })\r\n\r\n        sentenceArray = sentenceArray.map(cleanup)\r\n        console.log(sentenceArray)\r\n        responce_json.ipa_words = sentenceArray.map((value)=>{\r\n          return TextToIPA.lookup(value).text\r\n        })\r\n        \r\n        //Starting with {\"error\":\"\",\"sentence\":\"\",\"ipa_words\":[\"ðʌ OR ðʌˈ OR ði\",\"bæˈtɚi\",\"hɔˈɹs\",\"stejˈpʌl\"]}\r\n        //Ending with   {\"error\":\"\",\"sentence\":\"\",\"ipa_words\":[\"ðʌ\"             ,\"bæˈtɚi\",\"hɔˈɹs\",\"stejˈpʌl\"]}\r\n        // split the multple ipa forms and take only the first one\r\n        // \"ðʌ OR ðʌˈ OR ði\" => becomes  [\"ðʌ\", \"ðʌˈ\", \"ði\"] and retulting in \"ðʌ\"\r\n        responce_json.ipa_words = responce_json.ipa_words.map((word)=>{\r\n            return word.split(\"OR\").map((value)=>{ return value.trim()})[0]\r\n        })\r\n\r\n        //ipa sentense version with spaces between words\r\n        responce_json.sentence_ipa = responce_json.ipa_words.reduce((accumulator, currentValue)=> { \r\n            return accumulator +\" \"+ currentValue\r\n        });\r\n\r\n        res.send(JSON.stringify(responce_json))\r\n    }else{\r\n        res.send(JSON.stringify(responce_json))\r\n    }\r\n})\r\n\r\napp.listen(PORT, () => console.log(`Example app listening on port ${PORT}!`))\r\n"]}